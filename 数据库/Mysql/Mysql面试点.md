# Mysql面试点

## 数据库概念

### 数据库引擎

#### 1. InnoDB存储引擎
- 支持事务安全表（ACID），支持行锁定和外键。Mysql5.5之后是默认引擎
- 提供了提交、回滚和崩溃恢复能力的事务安全特性
- 为处理巨大数据量的最大性能设计
- 在主内存中缓存数据和索引而维持自己的缓冲池。表和索引放在同一个逻辑表空间中，表空间可以包含多个文件。
- 锁是行级的，粒度小，写操作不会锁定全表，在并发高的时候，效率高。适合update和insert多的表
- 支持外键完整性约束
- 不保存行数，执行 `SELECT COUNT(*) FROM table;`时需要全表扫描。
- 插入缓冲
  - 对于非聚集索引的插入和更新操作，会先插入到内存中。如果该索引页已经在缓冲池中，直接插入；否则，先将其插入缓冲池中，再以一定的频率和索引页合并
  - 可以将同一索引页的多个插入合并到一个IO操作中，大大提高写性能
  - 可能会导致数据库宕机后实例恢复时间变长，如果执行了大量的插入或更新操作，涉及了非聚集索引，内存中会有大量的插入缓冲区数据没有合并至索引页
- 两次写
  - 部分写失效：数据库正从内存向磁盘写一个数据页，数据库宕机，导致这个页只写了部分数据，导致了数据丢失
  - 当刷新缓冲池脏页时，并不直接写到数据文件中，而是先拷贝到内存中的两次写缓冲区
  - 接着从缓冲区分两次写入磁盘共享表空间中，每次写入1MB
  - 上一步完成后，再将缓冲区数据写入数据文件
- 自适应哈希索引
  - 实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中“自适应哈希索引缓冲区”建立哈希索引

#### 2. MyISAM存储引擎
- 不支持事务
- 用一个变量保存了整个表的行数，查询快
- 锁是表级的，所以频繁更新数据效率低，适合大量查询的表
- 每个表的最大索引数是64（可以通过编译改变），最大的键长度是1000B（也可以通过编译改变）
- BLOB和TEXT列可以被索引，NULL允许在索引的列中
- 可以把数据文件和索引文件放在不同的目录下
- 每个字符列可以有不同的字符集
- 创建数据库时，产生3个文件，frm存储表定义，MYD是数据文件，MYI是索引文件

#### 3. MEMORY存储引擎

- 将表中数据存储到内存中，为查询和引用其他表数据提供快速访问
- MEMORY每个表最多支持32个索引，每个索引16列，以及500B最大键长度
- 存储引擎执行HASH和BTREE索引
- 可以在一个MEMORY表中有非唯一键
- 使用一个固定的记录长度格式
- 不支持BLOB和TEXT
- 支持AUTO_INCREMENT列和对可包含NULL值的列索引
- 所有客户端共享，内容被存在内存中
- 不再需要MEMORY表时，执行`DELETE FROM  or TRUNCATE TABLE or DROP TABLE`

#### MyISAM和InnoDB比较

|                        | MyISAM                                                       | InnoDB                                                       |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 存储结构               | 每张表被存放在三个文件：fm定义表格定义、MYD数据文件，MYI索引文件 | 所有表都保存在同一个数据文件中（也可能是多个文件，或者独立的表空间文件） |
| 存储空间               | MyISAM可被压缩，存储空间下                                   | InnoDB需要更多的内存和存储，会在主内存中建立专用的缓冲池用于高速缓冲数据和索引 |
| 可移植行、备份及恢复   | 因为数据是以文件的形式存储，跨平台的数据转移方便，备份和恢复可单独针对某个表进行操作 | 可以拷贝数据文件、备份binlog或者用mysqldump                  |
| 文件格式               | 数据和索引分开存储，分别是数据.MYD，索引.MYI                 | 数据和索引集中存储的.ibd                                     |
| 记录存储顺序           | 按记录插入顺序保存                                           | 按主键大小有序插入                                           |
| 外键                   | 不支持                                                       | 支持                                                         |
| 事务                   | 不支持                                                       | 支持                                                         |
| 锁支持                 | 表级锁定                                                     | 行级锁定、表级锁定，锁定力度下并发能力高                     |
| SELECT                 | 更优                                                         |                                                              |
| INSERT、UPDATE、DELETE |                                                              | 更优                                                         |
| select count(*)        | myisam内部维护了一个计数器，可以取出count                    |                                                              |
| 索引的实现             | B+树索引，非聚簇索引                                         | B+树索引，聚簇索引                                           |
| 哈希索引               | 不支持                                                       | 支持                                                         |
| 全文索引               | 支持                                                         | 不支持                                                       |

### MyISAM & InnoDB索引区别

- 前者是非聚集索引，后者是聚集索引
- InnoDB主键索引的叶子结点存储了行数据，主键索引高
- MyISAM索引的叶子结点存储着行数据地址，需要再寻址一次才能得到数据
- InnoDB非主键索引的叶子结点存储的是主键和其他带索引的列数据

### 聚集索引和非聚集索引
- InnoDB是聚集索引，MyISAM是非聚集索引。
- 聚集索引的文件存放在主键索引的叶子节点上，所以InnoDB必须要有主键。主键索引效率高，辅助索引需要查两次，第一次查主键索引，再通过主键查询到数据
- 非聚集索引的数据文件是分离的，索引保存的数据文件的指针，主键索引和辅助索引是分离的。

### Mysql的MVCC原理

#### 基本原理
[Mysql MVCC原理](https://juejin.im/post/5c68a4056fb9a049e063e0ab)
- MVCC是多版本并发控制，简单地说每个连接到数据库的用户看到的数据只是一个快照，在写操作或
事务提交之前对于其他用户是不可见
- 在更新一条数据库记录时，不会直接覆盖旧数据，而是将旧数据标记为过时版本，并在其他地方增加
新版本数据，新旧数据会同时存在。这种方式允许其他用户读取正在被别人修改的数据的旧数据。
- 需要系统周期性整理过时的旧数据。Mysql的MVCC提供了时点一致性视图，并发控制下的读事务一般
使用时间戳或事务ID去标记当前读的数据库的版本，读取这个版本的数据。
- 这种情况下读写是分离的，读取旧版本数据，写入新版本数据
- 一句话总结：MVCC就是同一份数据临时保存多版本的方式，进而实现并发控制

#### 实现细节
1. Mysql建表的时候，每个表有三个隐藏的行，其中两个是`DB_TRX_ID数据行的版本号`&`回滚指针DB_ROLL_PTR`
2. 插入数据的时候，事务的ID会记录到DB_TRX_ID
3. 删除数据的时候，事务的ID会记录到DB_ROLL_PT，数据当时并没有被实际删除
4. 修改数据的时候，会事先复制一条被修改的数据，并在DB_ROLL_PT记录事务ID，然后在新的数据里
记录DB_TRX_ID
5. 查询的时候：1、查询数据行版本号早于当前事务版本的数据行记录；2、查询删除版本号为NULL或大于
当前事务版本号的数据，确保查询的数据行记录在事务开启前没有被删除。

### 事务的4个特性
1. 原子性：事务是在逻辑上不可分割的操作单元，其所有语句要么全都执行要么全都不执行
2. 一致性：逻辑上的保证操作，将数据库从某个一致性状态转换到另一个一致性状态（比如两个共有5000元，互相赚钱都要保证这两个人总和还是5000元）
3. 隔离性：在并发的情况下，避免同时对数据库的多个操作对数据一致性产生影响，需要隔离并发运行的多个事务间的互相影响
4. 持久性：一旦事务提交成功，对数据的修改是持久性的。即时发生了系统故障，已提交的事务所做的数据的修改也不会丢失。

### 事务的不进行隔离会产生的问题
1. 脏读：A事务读取了被B事务正在修改但没有提交的数据。B事务在多次修改某个数据，但一直未提交修改。这是另一个A事务来读取被B修改的数据，会造成两个事务的数据不一致
2. 不可重复读：同一个事务中，同一个查询在Time1时刻读取某一行，在time2时刻重新读取这一行数据，发现一行的数据已经被另一个事务修改或删除了。 <i>不可重复读是由于事务并发修改同一条记录导致的</i>
3. 幻读：同一个事务中，同一查询多次执行的时候，由于其他插入操作的事务提交，会导致每次返回不同的结果集。<i>幻读是由于并发事务增加记录导致的</i>

### 事务的四种隔离级别
1. Read Uncommited未提交读：所有事务都可以看到其他未提交事务的执行结果。
2. Read Committed提交读：大多数数据库默认的隔离级别。一个事务从开始直到提交，其他事务都不可读取到期间修改的结果。
3. Repeated Read可重复读：确保同一个事务在多次读取同样的数据时候，得到同样的结果（InnoDB通过MVCC实现）
4. Serializable可串行化：最高的隔离级别，强制事务的排序，强制事务串行执行，使之不能相互冲突。原理是在每个读的数据行上加上共享锁。

### 视图的概念
- 视图是从数据库基本表中选取数据组成的逻辑窗口。它是一个虚拟表，内容由查询定义。行和列数据来自由定义视图的查询引用的表，并在引用视图的时候动态生成。
- 对视图的修改实际上会对基表修改，基表的修改也会反映在视图上。
- 视图的作用
    1. 隐藏了原表的数据的复杂性，提供了一定的逻辑独立性
    2. 可以控制用户可以访问的内容
    3. 能够简化结构，执行复杂查询操作
    4. 使用户能够以多种角度、更灵活地观察和共享同一数据
    
### SQL注入
- 用户恶意构造sql语句传给服务器，服务在使用用户的输入去数据库查询的时候触发用户精心构造的sql语句。
- 为防止sql注入攻击，需要注意：
    1. 不要信任用户的输入，通过正则匹配或限制长度的方式对用户的输入进行校验， 对单引号进行转换
    2. 永远不要使用动态拼装SQL语句，可以使用参数化的SQL或存储过程进行数据查询
    3. 不使用管理员权限的数据库连接，建议为每个应用赋予单独的权限
    4. 对机密的信息不直接存储，而是加密或hash处理
    5. 应用的异常提示应给出尽量少的信息，最好使用自定义的错误信息对原始的错误信息进行包装
    6. 借助软件和网站平台对SQL注入进行检测
    
### 乐观锁和悲观锁
#### 1. 悲观锁
- 每次去读取数据的时候，都认为别的事务会修改数据。所以，每次在读数据的时候，都会上锁，以防止其他事务读取或修改这些数据。悲观锁会导致其他修改同个数据的事务阻塞。
- 适合更新频繁的表

#### 2. 乐观锁
- 每次去读数据的时候都认为别的事务不会修改，但在更新的时候，会判断在此期间别人有没有去更新这个数据。
- 适合更新不频繁，查询比较多的场合。
- 使用版本控制的乐观锁增加Number or Timestamp or Date列，知道最后修改的时间，每次修改的前后比对值是否相同，相同说明期间没有被别人修改过，修改数据后更新字段。
- 使用校验和检查数据前后有无更新，但是资源开销大

## 数据库三大范式
[数据库三范式](https://blog.csdn.net/Dream_angel_Z/article/details/45175621)
- 第一范式：强调列的原子性，即列不能够再拆分成其他几列
- 第二范式：满足第一范式的情况下，还需要包含两部分内容：一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。
    - 要求实体的属性完全依赖主键，如果存在属性仅依赖关键字的一部分属性，那么这个属性和主关键字应该分离出来形成一个实体
    - 新实体和原实体之间是一对多关系
- 第三范式：在第一范式基础上，任何非主属性不依赖于其他非主属性，消除第二范式的传递依赖
- 第二范式和第三范式区别：
    - 第二范式区分非主键列是否完全依赖于主键，还是依赖于主键的一部分；
    - 第三范式区分非主键列是直接依赖于主键，还是直接依赖于非主键列

## MySQL有关权限的表有哪几个
- user: 记录允许连接到服务器的用户账户信息，里面的权限是全局级的
    - 允许配置用户在全局范围内的对数据和数据库进行的操作，除了增删改查，还有关闭服务器，超级权限和加载用户的权限
    - 和安全有关的列，包括ssl，授权插件
    - 资源控制列，比如每小时允许执行的查询更新操作次数，连接操作数等
- db: 记录各个账号在各个数据库上的操作权限，决定用户可以从哪个主机存取哪个数据库的数据
- host: 存储了某个主机对数据库的操作权限
- table_priv: 对表设置操作权限
- columns_priv: 对列设置操作权限
- procs_priv: 对存储过程和存储函数设置操作权限

## MySQL的binlog有几种录入格式？有什么区别

### 什么是Binlog
binlog记录了MySQL数据库的变化，以事务安全的方式包含更新日志中可用的所有信息。包含了所有更新了数据或者潜在可能更新数据的语句。语句以"事件"的形式保存
它不包含没有修改任何数据的语句。

### 录入格式
- statement：每一条会修改数据的sql都会记录在binlog中。由于sql执行的有上下文，保存的时候需要保存相关信息
- row: 不记录sql语句的上下文信息，仅保存那条记录被修改，记录单元为每一行的改动。当表结构改变时，记录语句而不会记录每一行
- mixed: 普通操作使用statement，无法使用statement时采用row



## B+Tree 和 B-Tree原理

[https://www.kancloud.cn/kancloud/theory-of-mysql-index/41844](https://www.kancloud.cn/kancloud/theory-of-mysql-index/41844)

- B-tree

![B-tree](https://box.kancloud.cn/2015-07-07_559b77f164271.png)

- B+tree

  ![B+tree](https://box.kancloud.cn/2015-07-07_559b77f19830b.png)

## 最左前缀原理

[最左前缀原理与优化](https://www.kancloud.cn/kancloud/theory-of-mysql-index/41857)

- 当查询条件精确匹配索引的左边连续一个或几个列时，组成了最左前缀

## 创建索引的原则

- 符合最左前缀匹配原则
- 查询频繁的字段创建索引
- 更新频繁的字段不适合创建索引
- 不能有效区分数据的列不适合做索引列
- 尽量扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a, b)索引，那就只需修改原来的索引
- 定义有外键的数据列一定要有索引
- 查询涉及很少的列，重复值多的列不要建立索引
- text,blob的列不要建立索引

## Hash索引和B+树的区别

- hash
  - 进行等值查询快，但是无法进行范围查询
  - 不支持模糊查询以及多列索引的最左前缀匹配
  - 不稳定、性能不可预测，某个键值存在大量重复的时候，发生hash碰撞，会使效率降低
- B+树
  - 节点是按顺序排序的，天然支持范围查询

## 

非聚集索引一定会回表查询吗

- 如果查询语句中选择的字段全部命中了索引，就不需要回表查询

## 锁的粒度有哪些

- 行级锁：只针对当前操作的行进行加锁。开销大，加锁慢，会出现死锁，但是发生锁冲突的概率低，并发高
- 表级锁：对当前操作的整张表加锁，实现简单，资源消耗少。开销小，加锁快，不会出现死锁，但发生锁冲突的概率高，并发低
- 页级锁：介于行级锁和表级锁中的一种锁，一次锁定相邻的一组记录

### 锁的类别

- 共享锁：又叫读锁，当用户进行数据的读取时，对数据加上共享锁，共享锁可以同时加上多个
- 排他锁：又叫写锁，用户写入数据时加上排他锁。排他锁只能加一个。

## 存储过程

存储过程是一个预编译的SQL语句，允许模块化的设计，只需要创建一次，就能多次调用。

- 优点
  - 存储过程预编译，执行效率高
  - 代码直接存在数据库，可以直接调用，减少网络通讯
  - 安全性高，执行存储过程需要有一定权限的用户
  - 可以复用，减少开发人员的工作量
- 缺点
  - 调试麻烦，重新编译问题，维护复杂

## 触发器

触发器是定义在表上的一类由事件驱动的特殊的存储过程，当出发某个事件时，会自动执行这些代码

使用场景

- 可以通过数据库中相关表实现级联更改
- 实时监控某张表中的某个字段的更改而需要作出相应的处理
- 生成某些业务的编号

触发器

- Before  insert
- after insert
- before update
- after update
- before delete
- after delete

## SQL的约束

- NOT NULL: 控制字段不能为空
- UNIQUE: 控制字段值不能重复
- PRIMARY KEY: 主键约束
- FOREIGN KEY: 外键约束，和其他表的之间的关联关系
- CHECK: 控制字段的值范围

## Mysql主重复制原理

- 主节点记录了改变数据库的语句放入binlog
- 从节点维护一个io线程从主节点拉取binlog内容，放入自己的relay log中
- 从节点从relay log读取语句执行

## 删除百万级别以上的数据如何删除？

先删除索引，然后删除无用数据，删除后重新创建索引

### MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？

基于索引完成行锁

```sql
select * from tab_with_index where id = 1;
```

## 索引可能失效的场景
- WHERE里查询条件有不等于号，使用了函数将无法用到索引
- JOIN操作中，只有在主键和外键数据类型相同时才能用到索引
- WHERE里使用了LIKE和REGEXP，只有在搜索模版的第一个字符不是通配符的情况下才能使用索引
- ORDER BY 排序条件不是一个查询条件表达式的情况下才能使用索引
- 使用OR的情况下可能会失效

