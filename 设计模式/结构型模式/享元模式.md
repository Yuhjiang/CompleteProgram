# 享元模式

## 场景
- 程序必须支持大量对象且没有足够的内存容量时使用享元模式。
- 模式所获的收益大小取决于使用它的方式和情景。 它在下列情况中最有效
    - 程序需要生成数量巨大的相似对象
    - 这将耗尽目标设备的所有内存
    - 对象中包含可抽取且能在多个对象间共享的重复状态。
    
## 实现方式
1. 将需要改写为享元的类成员变量拆分为两个部分
    - 内在状态： 包含不变的、 可在许多对象中重复使用的数据的成员变量
    - 外在状态： 包含每个对象各自不同的情景数据的成员变量
2. 保留类中表示内在状态的成员变量， 并将其属性设置为不可修改。 这些变量仅可在构造函数中获得
初始数值。
3. 找到所有使用外在状态成员变量的方法， 为在方法中所用的每个成员变量新建一个参数， 
并使用该参数代替成员变量。
4. 可以有选择地创建工厂类来管理享元缓存池， 它负责在新建享元时检查已有的享元。 如果选择使用
工厂， 客户端就只能通过工厂来请求享元， 它们需要将享元的内在状态作为参数传递给工厂。
5. 客户端必须存储和计算外在状态 （情景） 的数值， 因为只有这样才能调用享元对象的方法。
 为了使用方便， 外在状态和引用享元的成员变量可以移动到单独的情景类中。
 
## 优点
- 如果程序中有很多相似对象， 那么你将可以节省大量内存

## 缺点
- 可能需要牺牲执行速度来换取内存， 因为他人每次调用享元方法时都需要重新计算部分情景数据。
- 代码会变得更加复杂

