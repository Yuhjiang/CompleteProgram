# 计算机基础知识
## 死锁
- 死锁是指多个进程在执行过程中，由于资源竞争申请对方占用的资源时后，永远无法分配到对方进程申请的资源而无法继续运行的现象。
- 产生的原因：1、系统资源不足；2、进程运行推进的顺序不当；3、资源分配不当；4、占用资源的程序奔溃
- 产生的条件：
    - 互斥条件：一个资源每次只能被一个进程使用
    - 请求与保持条件：当一个进程因请求资源而被阻塞的时候，对已获得的资源不释放
    - 不可剥夺条件：进程已经获得的资源，在未使用完之前，不能被强行剥夺
    - 循环等待条件：若干进程之间形成一种首尾相接的循环等待资源关系

## 进程和线程、协程
- 协程又称为微线程，英文名Coroutine，是在执行任务A时，可以随时中断，去执行任务B，程序能主动控制切换，没有切换线程的开销，所以执行效率高。
- 进程和线程的主要差别在于不同的操作系统资源管理方式
- 进程有独立的地址空间，一个进程崩溃后，不会对其他的进程产生影响
- 线程是一个进程中不同的执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间。线程挂掉会导致进程挂掉，所以多进程要比多线程的程序健壮
- 进程切换时耗费资源较大，所以效率较差。对一些要求同时进行且需要共享变量的并发操作，推荐用线程，但是Python的多进程模块，有进程共享的队列
- 进程有独立的内存单元，多个线程共享内存单元
- 进程是系统进行资源分配和调度的一个独立单位，线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位，但线程自己基本不拥有系统资源，只拥有运行中必须的资源（如程序计数器，一组寄存器和栈）
- 一个线程可以创建和撤销另一个线程，同一个进程中的多个线层可以并发执行

## 线程安全和原子性、可见行、有序性
- 原子性是指一个操作不可中断，要么全部执行成功要么全部执行失败
- 有序性是编译器和处理器为了优化程序性能而对指令序列进行重排序，可能会导致多线程程序出现内存可见性问题
- 可见性是多个多个线程访问同一个共享变量时，其中一个线程对这个共享变量值的修改，其他线程能够立刻获得修改后的值
- 线程之间的数据共享时，会因线程对数据的处理进度不同，导致数据出错。为了保证线程安全，可对线程加锁，用锁来控制线程间的数据共享

## 内存泄漏和内存溢出是什么
- 内存溢出: 程序在申请内存时，没有足够的空间供其使用，出现了out of memory
- 内存泄漏: 程序在申请内存后，无法释放已申请的内存空间，出现了memory lea。无用对象持续占有内存或无用对象的内存得不到即使释放，会造成内存空间的浪费。

## select、poll和epoll和中断
[https://juejin.im/post/5c9dd8e6f265da30ae313a01](https://juejin.im/post/5c9dd8e6f265da30ae313a01)
首先需要解释文件描述和IO模型
- 文件描述符(fds)：当程序打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。
- IO多路复用是一种同步IO模型，实现一个进程可以监视多个文件句柄(socket、文件或管道等)，一旦某个文件句柄就绪，就能够通知程序进行相应的读写操作。IO多路复用相比于多线程优势在于系统开销小，系统不必创建和维护进程或线程，免去了线程或进程切换带来的开销

### select
- 时间复杂度O(N)，select仅仅知道了有IO事件发生，但是不知道是哪几个流，只能无差别轮询所有流，找出能读写数据的流
- 有三种类型的描述符类型: readset、writeset、exceptset，分别对应读、写、异常条件。fd_set使用数组实现
- 有参数timeout，调用select会一直阻塞直到有描述符的事件达到或等待时间超过timeout
- 调用过程
    - 当用户进程调用select时，select会将需要监控的readfds集合拷贝到内核空间
    - 遍历socket检查是否有可读事件，遍历完之后没有可读事件，便调用schedule_timeout进入循环，进程开始睡眠
    - 如果某个IO事件发生了或等待timeout了，调用select的进程会唤醒遍历监控的readfds，收集可读事件返回给用户
- 问题
    - 被监控的fds集合限制为1024
    - fds集合需要从用户空间拷贝进内核空间
    - fds的IO事件通知不够精确

### poll
- 时间复杂度O(N)，将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，没有最大连接数的限制，因为它是基于链表来存储的
- 和select类似，但是poll没有最大文件描述符的数量限制，使用了pollfd结构而不是fd_set
- pollfd使用了链表，并提供更多的事件类型，对描述符的重复利用比select高

### epoll
- 时间复杂度O(1)，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的IO事件通知我们，所有epoll实际上是事件驱动(每个事件关联上fd)。
- epoll_ctl()用于向内核注册新的描述符或者改变某个文件描述符的状态。
- 已注册的描述符在内核中会被维护在一颗红黑树，通过回调函数内核将IO准备好的描述符加入到一个链表管理
- 进程调用epoll_wait()便可以得到事件完成的描述符
- epoll只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不用通过轮询来获得事件完成的描述符
- epoll描述符事件有两种触发模式LT(level trigger) & ET(edge trigger)
    - LT模式：epoll_wait()检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理事件，下次调用epoll_wait()时会再次通知进程
    <br />支持阻塞和非阻塞IO
    - ET模式：通知之后立即处理事件，减少了epoll事件被重复触发的次数，效率比LT高，只支持非阻塞IO
    
## 阻塞IO和非阻塞IO
### 阻塞IO
![阻塞IO](https://user-gold-cdn.xitu.io/2019/3/31/169d16a9a67b8a0a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
- 进程发起系统调用，然后进入等待，一直等到数据报就绪，这时候数据还在内核缓冲区，需要将数据报返回给进程缓冲区

### 非阻塞IO
![非阻塞IO](https://user-gold-cdn.xitu.io/2019/3/31/169d18e8f8033ded?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
- 进程发起系统调用后，如果数据没有准备好，内核返回一个错误码，进程还可以继续执行，但需要不断进行系统调用来判断IO是否完成

## 调度

- 先来先服务调度算法FCFS：每个进程就绪后加入就绪队列。正在运行的进程结束后，选择在就绪队列中存在时间最长的进程运行。
  - FCFS属于不可剥夺算法，对所有作业公平，但当一个长作业先到达系统，会使后面许多短作业等待很长时间
  - FCFS算法简单，效率低，对长作业有利，对短作业不利，有利于CPU繁忙型作业，不利于IO繁忙型作业
- 时间片轮转调度算法：主要适用于分时系统。系统将所有就绪进程按照到达时间的先后次序排成一个队列，进程调度从事选择就绪队列中第一个进程执行，但是仅能运行一个时间片，用完一个时间片后，进程必须释放出计算资源给下一个就绪的进程，该进程会返回到就绪队列的末尾重新排队，等待再次运行
  - 如果时间片选择过大，会使时间片轮转调度退化为先来先服务调度
  - 如果时间片选择过小，会使进程频繁切换，增大CPU的开销
- 短作业优先调度算法SJF：从就绪队列利选择一个或若干个估计运行时间最短的作业，调入内存运行。短进程优先调度算法是从就绪队列中选择一个估计运行时间最短的进程执行
  - 属于非抢占策略，原则是下一次选择预计处理时间最短的作业，可用于作业调度和进程调度。
  - 对长作业不利，不能保证作业被及时处理，长作业的周转时间会增加，可能会造成长作业长期不被调度
- 最短剩余时间优先：进程调度总是选择预期剩余时间最短的进程，当进程加入到就绪队列时，如果它的比运行进程有更短的运行剩余时间，新进程就可能抢占正在运行的进程
  - 属于抢占性策略
- 高响应比优先调度算法：根据比率R=(w+s)/s（R为响应比，w为等待处理时间，s为预计的服务时间）如果进程被立即调用，则R等于归一化周转时间（周转时间和服务时间比率）。调度规则为：当前进程完成或阻塞时，选择R值最大的就绪进程；当偏向短作业时，长进程得不到服务会持续增加等待时间，从而增大R值。
  - 和短作业优先调度和最短时间优先调度一样都需要估计服务时间
- 优先级调度算法：既可以用于作业调度，又可以用于进程调度。算法每次从后备作业队列中选择优先级最高的一个或几个作业，调入内存，分配必须要的资源，创建进程并放入就绪队列。进程调度中，算法每次从就绪队列中选择优先级最高的进程执行
  - 非剥夺式优先级调度算法：当进程正在执行时，即使有某个更重要的进程进入就绪队列，仍让当前进程继续运行
  - 剥夺式优先级调度算法：如果某个更重要的进程进入就绪队列，会立即暂停正在运行的进程，并让新进的进程运行
  - 静态优先级：优先级是在创建进程时确定的，在进程的整个运行期间保持不变。
  - 动态优先级：进程运行过程中，根据进程情况的变化动态调整优先级。主要依据是进程占用CPU时间的长短，就绪进程等待CPU时间的长短
- 多级反馈队列调度算法
  - 设置多个就绪队列，并为各个队列赋予不同的优先级，第1级队列优先级最高，其余队列优先级逐次降低
  - 赋予各个队列中进程执行时间片的大小也不同，优先级越高的队列中，每个进程的运行时间片就越小。
  - 新进程进入内存后，会放在第1级队列末尾，按照FCFS原则排队等待调度，如果不能在时间片内完成任务，调度算法会把进程放入下一级队列的末尾，然后按照FCFS原则等待调度执行。当降到最后一级时，使用时间片轮转调度
  - 仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行。如果在执行第i级队列，有新进程进入优先级较高的队列，则新进程会抢占正在运行进程的计算资源，原来的进程放到第i级队列末尾。

## UNIX进程间通信方式

进程间通信就是多个进程之间的数据交互。每个进程有自己的虚拟地址空间，会导致进程之间的数据交互变得十分困难。进程间通信的本质是多个进程之间是否可以访问同一块内存/缓冲区。

- 进程间通信的目的：
  - 数据传输：进程需要将自己的数据发送给另一个进程
  - 资源共享：多进程之间共享同样的资源
  - 通知时间：一个进程可能向其他进程或进程组发送消息，表示发生了某个事件
  - 进程控制：有些进程希望能完全控制另一个进程的执行，及时知道进程的状态改变

- 管道：内核中的一块缓冲区，用于传输数据资源
  - 子进程和父进程可以进行数据传输和通信，因为fork出来的子进程复制了父进程的程序地址空间。只能用于具有亲缘关系的进程间通信。
- 命名管道：一类特殊的文件，可用于同一机器上所有进程之间的通信，拥有匿名管道的所有特性。需要用户自己打开调用。
- 消息队列：操作系统为消息队列维护了一个结构体，传输的是数据块。
- 共享内存：进程间通信最快的一种方式，共享内存是在物理内存中开辟一段空间，映射到自己的虚拟空间。如果多个进程都进行了映射，则这些进程可以通过共享内存进行通信。
  - 共享内存是直接对映射到虚拟地址的物理地址进行操作，减少了由用户空间到内核空间，再由内存空间到用户空间的拷贝过程
- 信号量：信号量是一个特殊的变量，程序对其访问都是原子操作，并且只允许对它进行(P信号量）和发送（V信号）。
  - P(信号量)：如果信号量大于0，就减1，如果值为0，就挂起进程
  - V(信号量)：如果有其他进程因等待信号量而被挂起，就让他恢复运行，如果没有进程因等待挂起。就给他+1