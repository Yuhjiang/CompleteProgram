# 计算机基础知识
## 死锁
- 死锁是指多个进程在执行过程中，由于资源竞争申请对方占用的资源时后，永远无法分配到对方进程申请的资源而无法继续运行的现象。
- 产生的原因：1、系统资源不足；2、进程运行推进的顺序不当；3、资源分配不当；4、占用资源的程序奔溃
- 产生的条件：
    - 互斥条件：一个资源每次只能被一个进程使用
    - 请求与保持条件：当一个进程因请求资源而被阻塞的时候，对已获得的资源不释放
    - 不可剥夺条件：进程已经获得的资源，在未使用完之前，不能被强行剥夺
    - 循环等待条件：若干进程之间形成一种首尾相接的循环等待资源关系

## 进程和线程、协程
- 协程又称为微线程，英文名Coroutine，是在执行任务A时，可以随时中断，去执行任务B，程序能
主动控制切换，没有切换线程的开销，所以执行效率高。
- 进程和线程的主要差别在于不同的操作系统资源管理方式
- 进程有独立的地址空间，一个进程崩溃后，不会对其他的进程产生影响
- 线程是一个进程中不同的执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间。
线程挂掉会导致进程挂掉，所以多进程要比多线程的程序健壮
- 进程切换时耗费资源较大，所以效率较差。对一些要求同时进行且需要共享变量的并发操作，推荐用
线程，但是Python的多进程模块，有进程共享的队列
- 进程有独立的内存单元，多个线程共享内存单元
- 进程是系统进行资源分配和调度的一个独立单位，线程是进程的一个实体，是CPU调度和分派的基本单位，
它是比进程更小的能独立运行的基本单位，但线程自己基本不拥有系统资源，只拥有运行中必须的资源
（如程序计数器，一组寄存器和栈）
- 一个线程可以创建和撤销另一个线程，同一个进程中的多个线层可以并发执行

## 线程安全和原子性、可见行、有序性
- 原子性是指一个操作不可中断，要么全部执行成功要么全部执行失败
- 有序性是编译器和处理器为了优化程序性能而对指令序列进行重排序，可能会导致多线程程序出现
内存可见性问题
- 可见性是多个多个线程访问同一个共享变量时，其中一个线程对这个共享变量值的修改，其他线程
能够立刻获得修改后的值
- 线程之间的数据共享时，会因线程对数据的处理进度不同，导致数据出错。为了保证线程安全，可对
线程加锁，用锁来控制线程间的数据共享

## 内存泄漏和内存溢出是什么
- 内存溢出: 程序在申请内存时，没有足够的空间供其使用，出现了out of memory
- 内存泄漏: 程序在申请内存后，无法释放已申请的内存空间，出现了memory lea。无用对象持续占有
内存或无用对象的内存得不到即使释放，会造成内存空间的浪费。

## select、poll和epoll和中断
[https://juejin.im/post/5c9dd8e6f265da30ae313a01](https://juejin.im/post/5c9dd8e6f265da30ae313a01)
首先需要解释文件描述和IO模型
- 文件描述符(fds)：当程序打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。
- IO多路复用是一种同步IO模型，实现一个进程可以监视多个文件句柄(socket、文件或管道等)，一旦
某个文件句柄就绪，就能够通知程序进行相应的读写操作。IO多路复用相比于多线程优势在于系统开销小，
系统不必创建和维护进程或线程，免去了线程或进程切换带来的开销

### select
- 时间复杂度O(N)，select仅仅知道了有IO事件发生，但是不知道是哪几个流，只能无差别轮询所有流，
找出能读写数据的流
- 有三种类型的描述符类型: readset、writeset、exceptset，分别对应读、写、异常条件。fd_set使用数组实现
- 有参数timeout，调用select会一直阻塞直到有描述符的事件达到或等待时间超过timeout
- 调用过程
    - 当用户进程调用select时，select会将需要监控的readfds集合拷贝到内核空间
    - 遍历socket检查是否有可读事件，遍历完之后没有可读事件，便调用schedule_timeout进入循环，进程开始睡眠
    - 如果某个IO事件发生了或等待timeout了，调用select的进程会唤醒遍历监控的readfds，收集可读事件返回给用户
- 问题
    - 被监控的fds集合限制为1024
    - fds集合需要从用户空间拷贝进内核空间
    - fds的IO事件通知不够精确

### poll
- 时间复杂度O(N)，将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，没有最大连接数
的限制，因为它是基于链表来存储的
- 和select类似，但是poll没有最大文件描述符的数量限制，使用了pollfd结构而不是fd_set
- pollfd使用了链表，并提供更多的事件类型，对描述符的重复利用比select高

### epoll
- 时间复杂度O(1)，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的IO事件通知我们，所有
epoll实际上是事件驱动(每个事件关联上fd)。
- epoll_ctl()用于向内核注册新的描述符或者改变某个文件描述符的状态。
- 已注册的描述符在内核中会被维护在一颗红黑树，通过回调函数内核将IO准备好的描述符加入到一个链表管理
- 进程调用epoll_wait()便可以得到事件完成的描述符
- epoll只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不用通过轮询来获得事件完成的描述符
- epoll描述符事件有两种触发模式LT(level trigger) & ET(edge trigger)
    - LT模式：epoll_wait()检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理事件，下次调用epoll_wait()时会再次通知进程
    <br />支持阻塞和非阻塞IO
    - ET模式：通知之后立即处理事件，减少了epoll事件被重复触发的次数，效率比LT高，只支持非阻塞IO
    
## 阻塞IO和非阻塞IO
### 阻塞IO
![阻塞IO](https://user-gold-cdn.xitu.io/2019/3/31/169d16a9a67b8a0a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
- 进程发起系统调用，然后进入等待，一直等到数据报就绪，这时候数据还在内核缓冲区，需要将数据报返回给进程缓冲区

### 非阻塞IO
![非阻塞IO](https://user-gold-cdn.xitu.io/2019/3/31/169d18e8f8033ded?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
- 进程发起系统调用后，如果数据没有准备好，内核返回一个错误码，进程还可以继续执行，但需要不断进行系统调用来判断IO是否完成
