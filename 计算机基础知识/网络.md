# 网络知识

## HTTP和HTTPS区别
- HTTP协议是超文本传输协议，传输的信息是明文的，而HTTPS增加了SSL协议，加密了传输的报文。
- HTTP默认使用80端口，HTTPS默认使用443端口

## Cookie和Session的区别
- session数据存放在服务器端，Cookie数据存放在客户端
- session依赖与Cookie里的数据，如果浏览器禁用了cookie，那么session也会失效
- cookie的安全性比session差

## HTTP状态码
### 5种类型
1. 1**：信息，服务器收到请求，需要请求者继续执行操作
2. 2**：成功，操作被成功接收并处理
3. 3**：重定向，需要进一步的操作以完成请求
4. 4**：客户端错误，请求包含语法错误或者无法完成请求
5. 5**：服务器错误，服务器在处理请求的过程中发生了错误

### 常用状态码

| 状态码 | 名称 | 功能 |
| :---: | :---: |----|
|101|Switching Protocols|切换协议，服务器根据客户端的请求切换协议。只能切换更高级的协议，如切换到websocket|
|200|Ok|请求成功，一般用于get和post|
|201|Created|已创建，成功请求并创建了新的资源|
|202|Accepted|已接受，已经接受请求，但未处理完成|
|204|No Content|无内容，服务器处理成功， 但未返回内容|
|206|Partial Content|服务器成功处理了部分GTE请求|
|301|Moved Permanently|永久移动，请求的资源已被永久移动到了新URL上|
|302|Found|临时移动，与301类似，但是只是临时被移动，客户端应该继续使用原有URL|
|304|Not Modified|未修改，所请求的资源未修改|
|400|Bad Request|客户端请求的语法错误，服务器无法理解|
|401|Unauthorized|请求要求用户的身份认证|
|403|Forbidden|服务器理解请求客户端的请求，但是拒绝执行请求|
|404|Not Found|服务器无法根据客户端的请求找到资源。
|405|Method Not Allowed|客户端请求的方法被禁止|
|500|Internal Server Error|服务器内部错误，无法完成请求|
|502|Bad Gateway|作为网关或代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应|
|503|Service Unavailable|由于超载或服务器维护，暂时无法处理客户端的请求|
|504|Gateway Time-out|充当网关或代理的服务器未及时从远端服务器获取请求|

## TCP的三次握手
[TCP的三次握手和四次挥手](https://juejin.im/post/5b29d2c4e51d4558b80b1d8c)
(https://hit-alibaba.github.io/interview/basic/network/TCP.html)

![TCP三次握手](https://user-gold-cdn.xitu.io/2018/6/26/1643a1dd6df4813b?imageslim)

![TCP三次握手SYN和ACK关系](https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-made-three-way-handshake.png)

1. Client向Server发送syn，初始化客户端序列号（syn）
2. Server发送自己的syn，并且作为应答，发送Client的syn+1作为ack给Client（syn， ack）
3. Client收到Server的syn和ack，确认连接，并发送Server的syn+1作为ack给Server

## TCP的四次挥手
[TCP的三次握手和四次挥手](https://juejin.im/post/5b29d2c4e51d4558b80b1d8c)
(https://hit-alibaba.github.io/interview/basic/network/TCP.html)

![动图解释TCP四次挥手](https://user-gold-cdn.xitu.io/2018/6/26/1643a20296de1ff0?imageslim)
![详解TCP四次挥手过程](https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-closed-four-way-handshake.png)

1. Client想要结束连接，发送（FIN=1，seq=x）给Server，表示自己可以没有数据可以发送，但仍然
可以接收数据，并进入FIN_wait_1状态。
2. Server接收到FIN，发送确认包(ACK=1, ACKnum=x+1)，表示自己收到了Client发送的关闭请求
但自己还没有准备好关闭，进入Close_WAIT状态。Client接收到了这个ACK后，进入FIN_WAIT_2状态，
等待Server关闭连接
3. Server发送（FIN=1，seq=y），表示自己已经准备好结束，然后进入LAST_ACK状态，等待Client
最后的ACK
4. Client接收到了Server的ACK包后，发送确认包(ACK=1, ACKnum=y+1)，并进入TIME_WAIT状态，
Server接收到了最后ACK包，进入Close状态。
5. Client在一段时间（_两个最大段生命周期，2MSL，2 Maximum Segment Lifetime_），没有接收
到Server的ACK，认为Server关闭了连接，，Client也进入Close状态。

## SYN攻击

### 什么事SYN洪泛攻击？
- 在三次握手过程中，Server发送了ACK+SYN之后，收到Client的ACK之前的TCP连接称为半连接，服务器
处于SYN_RCVD，收到ACK后会进入Established。
- SYN攻击是指攻击Client在短时间内伪造大量不存在的IP，不断向Server发送SYN包，Server回复确认包，
并等待Client回应，但由于Client不存在，Server会不断重试直到超时，这些伪造的SYN包会长期占用
未连接队列，正常的SYN会被丢弃，导致目标系统运行缓慢

### 如何防范SYN攻击
- 当在Server上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。

## 会话跟踪

### 什么是会话？
客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话

### 什么是会话跟踪？
会话跟踪指的是对同一个用户对服务器的连续的请求和接受响应的监视。

### 为什么需要会话跟踪？
浏览器与服务器之间的通信是通过HTTP协议进行通信的，而HTTP协议是”无状态”的协议，它不能保存
客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要判断是否是
同一个用户，所以才有会话跟踪技术来实现这种要求。

### 常用技术

1. URL 重写:URL(统一资源定位符)是Web上特定页面的地址，URL重写的技术就是在URL结尾添加一个
附加数据以标识该会话,把会话ID通过URL的信息传递过去，以便在服务器端进行识别不同的用户。
2. 隐藏表单域:将会话ID添加到HTML表单元素中提交到服务器，**此表单元素并不在客户端显示**
3. Cookie: Cookie 是Web 服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到
服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将 Cookie 发送到客户端,
在客户端可以进行保存,以便下次使用。
4. Session: 每一个用户都有一个不同的 session，各个用户之间是不能共享的，是每个用户所独享的，
在 session 中可以存放信息。在服务器端会创建一个 session 对象，产生一个 sessionID 来标识
这个 session 对象，然后将这个 sessionID 放入到 Cookie 中发送到客户端，下一次访问时，
sessionID 会发送到服务器，在服务器端进行识别不同的用户。

## 跨站攻击
### CSRF（Cross-site Request Forgery，跨站请求伪造）
- 关键操作使用Post方法
- 使用验证码，关键操作需要用户验证
- 检测Referer的值，可以判断这个请求是合法的还是非法的
- CSRF-token，关键操作增加一个足够随机的，无法伪造的随机字符串，并且是一次性，每次使用完
都要重新获取一次，请求时带上token，校验token是否有效

### XSS（Cross-site Scripting，跨站脚本攻击）
- 用户在提交文章、评论内容时，写入了可执行的JS代码，并且服务器在接收到这些内容时没有做转义，
其他人在查看文章和评论时，就会触发脚本运行
- 对脚本的关键词进行转义，比如`<script>`

## HTTPS的原理
### TLS原理
- CA机构拥有非对称加密的公钥和私钥，并对明文信息进行hash计算，对计算后的结果用私钥加密，得到数字签名
- 证书包含了数字签名，加密算法，hash算法，明文信息（签发者，机构，到期时间）

### 建立连接的过程
1. 浏览器得到证书后，使用证书的公钥解密数字签名，然后用证书的hash算法计算明文信息，比对两个
结果是否一致。
2. 证书有效后，浏览器生成了一串随机对称密钥，然后用证书的公钥加密对称密钥，传给服务器
3. 服务器用证书的私钥解密得到对称密钥，然后用对称密钥加密后续的传输报文

### 中间人攻击
- 中间人攻击，是指攻击者和通讯的双方互相建立连接，并交换数据，使通讯双方都认为自己是和正确的
对方在私密通讯。中间人可以拦截双方的通讯，并插入新的内容
- 中间人无法调包证书：A向B发送了证书，中间人劫持了证书，并向B发送了自己的证书，但是证书里包含了明文的A的域名信息，
B只要比对一下证书内容和A是否匹配即可。
- 中间人无法篡改证书：中间人篡改了证书，但因为没有证书的私钥，导致无法加密hash计算后的摘要。
客户端收到证书后，用证书的公钥解密后得到的摘要和自己的计算出来的摘要不一致，就可以判断证书
是否被篡改

## 缓存机制
[https://www.cnblogs.com/chenqf/p/6386163.html](https://www.cnblogs.com/chenqf/p/6386163.html)
- Header里`Cache-Control`选择缓存的策略
- 'public'指令表示该响应可以被任何中间人缓存（比如CDN）。'private'则表示该响应是专用于某
单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。
- 强制缓存和对比缓存的区别:强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，
都需要与服务端发生交互,两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当
执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。
![强制缓存](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210135521072-1812985836.png)
![对比缓存](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141716838-764535017.png)

### 强制缓存
- _（HTTP1.0的东西，不太用了）Expires：Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据_
- Cache-Control
    - private：表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。
    - public：表示该响应可以被任何中间人缓存（比如CDN）
    - max-age=XXX：缓存的内容将在 xxx 秒后失效
    - no-cache：需要使用对比缓存来验证缓存数据
    - no-store：所有内容都不会缓存，强制缓存，对比缓存都不会触发
    
### 对比缓存
浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。
再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，
返回304状态码，通知客户端比较成功，可以使用缓存数据。

- Last-Modified:服务器在响应请求时，告诉浏览器资源的最后修改时间。
- If-Modified-Since:再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。
服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。
    - 若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；
    - 若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，
    告知浏览器继续使用所保存的cache。
- Etag（优先级高于Last-Modified):服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。
- If-None-Match（优先级高于If-Modified-Since):再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。
服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对。
    - 不同，说明资源又被改动过，则响应整片资源内容，返回状态码200
    - 相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache
    
![完整的缓存流程](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141453338-1263276228.png)

## GET&POST的区别
### GET
- get用于信息的获取，是安全和幂等的。
- get的URL长度，对于不同浏览器有不同的限制，而且nginx里也可以配置支持的最大长度
- 需要用户保存的链接，使用get

### POST
- post表示可能会修改服务器上的资源
- body内容没有大小限制
- post比get更安全，敏感的信息提交使用post

## 幂等
- 一个HTTP方法是幂等的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，
服务器的状态也是一样的。也就是说是幂等方法不应该具有副作用。
- GET：是幂等的，只用于获取资源，不应有副作用。不论调用一次还是N次副作用都是相同的。
- POST：不具备幂等性，因为会创建新的内容
- PUT：是幂等的，指更新内容，对同一URI进行多次PUT的副作用和一次PUT是相同的
- DELETE：是幂等的，多次删除同一个URI，结果是一样的。