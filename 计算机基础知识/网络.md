# 网络知识

## TCP的三次握手
[TCP的三次握手和四次挥手](https://juejin.im/post/5b29d2c4e51d4558b80b1d8c)
(https://hit-alibaba.github.io/interview/basic/network/TCP.html)

![TCP三次握手](https://user-gold-cdn.xitu.io/2018/6/26/1643a1dd6df4813b?imageslim)

![TCP三次握手SYN和ACK关系](https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-made-three-way-handshake.png)

1. Client向Server发送syn，初始化客户端序列号（syn）
2. Server发送自己的syn，并且作为应答，发送Client的syn+1作为ack给Client（syn， ack）
3. Client收到Server的syn和ack，确认连接，并发送Server的syn+1作为ack给Server

## TCP的四次挥手
[TCP的三次握手和四次挥手](https://juejin.im/post/5b29d2c4e51d4558b80b1d8c)
(https://hit-alibaba.github.io/interview/basic/network/TCP.html)

![动图解释TCP四次挥手](https://user-gold-cdn.xitu.io/2018/6/26/1643a20296de1ff0?imageslim)
![详解TCP四次挥手过程](https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-closed-four-way-handshake.png)

1. Client想要结束连接，发送（FIN=1，seq=x）给Server，表示自己可以没有数据可以发送，但仍然
可以接收数据，并进入FIN_wait_1状态。
2. Server接收到FIN，发送确认包(ACK=1, ACKnum=x+1)，表示自己收到了Client发送的关闭请求
但自己还没有准备好关闭，进入Close_WAIT状态。Client接收到了这个ACK后，进入FIN_WAIT_2状态，
等待Server关闭连接
3. Server发送（FIN=1，seq=y），表示自己已经准备好结束，然后进入LAST_ACK状态，等待Client
最后的ACK
4. Client接收到了Server的ACK包后，发送确认包(ACK=1, ACKnum=y+1)，并进入TIME_WAIT状态，
Server接收到了最后ACK包，进入Close状态。
5. Client在一段时间（_两个最大段生命周期，2MSL，2 Maximum Segment Lifetime_），没有接收
到Server的ACK，认为Server关闭了连接，，Client也进入Close状态。

## SYN攻击

### 什么事SYN洪泛攻击？
- 在三次握手过程中，Server发送了ACK+SYN之后，收到Client的ACK之前的TCP连接称为半连接，服务器
处于SYN_RCVD，收到ACK后会进入Established。
- SYN攻击是指攻击Client在短时间内伪造大量不存在的IP，不断向Server发送SYN包，Server回复确认包，
并等待Client回应，但由于Client不存在，Server会不断重试直到超时，这些伪造的SYN包会长期占用
未连接队列，正常的SYN会被丢弃，导致目标系统运行缓慢

### 如何防范SYN攻击
- 当在Server上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。

## 会话跟踪

### 什么是会话？
客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话

### 什么是会话跟踪？
会话跟踪指的是对同一个用户对服务器的连续的请求和接受响应的监视。

### 为什么需要会话跟踪？
浏览器与服务器之间的通信是通过HTTP协议进行通信的，而HTTP协议是”无状态”的协议，它不能保存
客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要判断是否是
同一个用户，所以才有会话跟踪技术来实现这种要求。

### 常用技术

1. URL 重写:URL(统一资源定位符)是Web上特定页面的地址，URL重写的技术就是在URL结尾添加一个
附加数据以标识该会话,把会话ID通过URL的信息传递过去，以便在服务器端进行识别不同的用户。
2. 隐藏表单域:将会话ID添加到HTML表单元素中提交到服务器，**此表单元素并不在客户端显示**
3. Cookie: Cookie 是Web 服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到
服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将 Cookie 发送到客户端,
在客户端可以进行保存,以便下次使用。
4. Session: 每一个用户都有一个不同的 session，各个用户之间是不能共享的，是每个用户所独享的，
在 session 中可以存放信息。在服务器端会创建一个 session 对象，产生一个 sessionID 来标识
这个 session 对象，然后将这个 sessionID 放入到 Cookie 中发送到客户端，下一次访问时，
sessionID 会发送到服务器，在服务器端进行识别不同的用户。

## 跨站攻击
### CSRF（Cross-site Request Forgery，跨站请求伪造）
- 关键操作使用Post方法
- 使用验证码，关键操作需要用户验证
- 检测Referer的值，可以判断这个请求是合法的还是非法的
- CSRF-token，关键操作增加一个足够随机的，无法伪造的随机字符串，并且是一次性，每次使用完
都要重新获取一次，请求时带上token，校验token是否有效

### XSS（Cross-site Scripting，跨站脚本攻击）
- 用户在提交文章、评论内容时，写入了可执行的JS代码，并且服务器在接收到这些内容时没有做转义，
其他人在查看文章和评论时，就会触发脚本运行
- 对脚本的关键词进行转义，比如`<script>`

## HTTPS的原理
### TLS原理
- CA机构拥有非对称加密的公钥和私钥，并对明文信息进行hash计算，对计算后的结果用私钥加密，得到数字签名
- 证书包含了数字签名，加密算法，hash算法，明文信息（签发者，机构，到期时间）

### 建立连接的过程
1. 浏览器得到证书后，使用证书的公钥解密数字签名，然后用证书的hash算法计算明文信息，比对两个
结果是否一致。
2. 证书有效后，浏览器生成了一串随机对称密钥，然后用证书的公钥加密对称密钥，传给服务器
3. 服务器用证书的私钥解密得到对称密钥，然后用对称密钥加密后续的传输报文

### 中间人攻击
- 中间人攻击，是指攻击者和通讯的双方互相建立连接，并交换数据，使通讯双方都认为自己是和正确的
对方在私密通讯。中间人可以拦截双方的通讯，并插入新的内容
- 中间人无法调包证书：A向B发送了证书，中间人劫持了证书，并向B发送了自己的证书，但是证书里包含了明文的A的域名信息，
B只要比对一下证书内容和A是否匹配即可。
- 中间人无法篡改证书：中间人篡改了证书，但因为没有证书的私钥，导致无法加密hash计算后的摘要。
客户端收到证书后，用证书的公钥解密后得到的摘要和自己的计算出来的摘要不一致，就可以判断证书
是否被篡改
