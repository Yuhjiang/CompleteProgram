# Python语言豆知识
何谓豆知识，就是一些奇怪的小知识点，不怎么常见，但是很有趣的特性

## pyc和py文件的不同之处

两种文件均保存字节代码，但是pyc是python文件的编译版本，与平台无关的代码，因此可以在任何支持pyc的平台上运行，Python会自动生成pyc文件（优化加载速度，而不是运行速度）

## Python什么叫做自省
- 自省能力是指：检查某些事物以确定他是什么，能做什么，知道什么。Python能够在运行中，获得对象的类型。
- 例如：type(), dir(), getattr(), hasattr(), isinstance()

## _和_name和__name和__name__的区别
- `_`代表上一条执行语句的结果。也可以用在特殊的临时变量
- `_name`单下划线指定属性和方法是私有的，不建议在外部调用但不能阻止。在`from <module> import *`时不会被导入
- `name_`后置下划线适合用于名称被Python语言中的关键字占用
- `__name`双下划线，会让Python重写属性名称，避免子类中的命名冲突。调用的时候，要用`instance._Class__name`。可以避免子类的方法覆盖父类的方法
- `__name__`内部的魔法方法，可以在类中重写这些方法

## 什么是闭包
- 内部函数可以引用外部函数的参数和局部变量，当外部函数返回内部函数时，相关参数和变量存在返回的函数中，这种特性被称为闭包。
- 闭包外部函数的参数可以在内存中保持
- 闭包是两个函数的嵌套，外部函数的返回值必须是内嵌函数

## 如何判断是函数还是方法
- `isinstance(obj.func, FunctionType) & isinstance(obj.func, MethodType)`
- 函数的情况：用类去调用，不并需要传入self参数。
- 方法的情况：用实例去调用，需要传入self参数
```python
class Foo:
    def __init__(self):
        self.name = 'ok'
        
    def func(self):
        return self.name

    foo = Foo()
    foo.func()  # 方法
    Foo.func(foo)   # 函数
```

## `__name__`属性的作用什么
一个模块被另一个程序第一次导入时，主程序会全部运行。如果想在模块被引入时，某一块程序不执行，可以使用`__name__`属性使程序块仅在模块自身运行时运行。`__name__`其值是`__main__`时，表明该模块自身执行，否则是被引入时执行。

## 迭代器和生成器是什么
- 迭代器是支持`__iter__`和`__next__`方法的对象，iter返回一个可迭代对象，next获取可迭代对象的值
- 生成器是简化版的迭代器，不用创建一个类，使用`yield`，在函数中，yield将结果回给调用者
```python
def repeat(value):
    while True:
        yield value
```

## 生成随机数
- `random.random()`生成一个0~1之间的随机浮点数
- `random.uniform(a, b)`生成[a, b]之间的浮点数
- `random.randint(a, b)`生成[a, b]之间的整数
- `random.randrange(a, b, step)`在指定集合[a, b)中，以step为步长，随机取一个数
- `random.choice(seq)`从特定序列中随机取一个元素
- `random.sample(seq, n)`从特定序列中随机取n个元素

## `__init__.py`的作用
- `__all__`控制导包的范围
- import导入包的时候，包的目录下的`__init__.py`就会执行

## `type`和`isinstance`的区别
- 两者都可以判断一个变量是否属于某一个类型
- type无法判断子类属于某一种父类
- isinstance可以判断子类是否属于某个父类

## `__new__`和`__init__`的区别
- `__new__`是实例对象创建之前被调用的，用于创建实例， new传入cls作为第一个参数，代表当前类。new必须有返回值，返回实例对象。
- `__init__`是实例对象创建后调用的，用来设置对象属性的一些初始值。init第一个参数是self，表示创建好的实例。init不用返回值。
- 如果new返回一个已经存在是的实例，init则不会被调用（可以用于创建单例）。如果new不返回任何对象，则init也不会执行。

## `__str__` & `__repr__`的作用和区别
- 都是将python对象转换为字符串
- print，format都会调用对象的__str__方法，而直接查看对象调用的是__repr__方法。
- 可以直接用str()和repr()调用相应的方法
- 每个类都需要__repr__方法，因为在没有__str__方法的情况，会自动调用__repr__方法。


## 内存回收机制
[https://zhuanlan.zhihu.com/p/83251959](https://zhuanlan.zhihu.com/p/83251959)
Python的内存回收主要是引用计数机制为主，标记-清楚和分代回收两种机制为辅

### 引用计数
- 每个对象维护一个ob_ref字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，
它的引用计数ob_ref加1，每当该对象的引用失效时计数ob_ref减1，一旦对象的引用计数为0，
该对象立即被回收，对象占用的内存空间将被释放。
- 缺点是需要额外的空间维护引用计数，不能解决对象的“循环引用”
- 会使引用计数+1的操作：对象被创建、被引用、作为参数传入函数、作为list等里的一部分
- 会使引用计数-1的操作：对象被显式删除、变量赋值了其他对象、离开作用域、list等被销毁

### 分代回收
- 将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。
- 新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。

### 标记清除
- 分为两个阶段：第一阶段是标记阶段，GC会把所有的"活动对象"打上标记，第二阶段是把那些没有标记的对象"非活动对象"进行回收
- 对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。

## Python传引用和传值的区别

- Python中所有东西都是对象，不可变对象包括strings, tuple, number，可变对象包括list,dict,set
- 函数传递参数的时候，实际上是传递引用，对于不可变对象的赋值，会使原变量指向新的不可变对象，对于可变对象的修改，是直接修改对象内的数据，对象指向的对象不会变化

## is和==

- is比较两个对象id是否相等，即比较两个对象是否指向同一块内存地址

- ==比较两个对象内容是否相等，默认调用对象的`__eq__`

## Socket编程
```python
"""
Server
"""
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind(('127.0.0.1', 3000))
s.listen(5)     # 设置backlog-socket连接最大排队数量
while True:
    c, addr = s.accept()
    c.send('hello')
    c.close()

"""
Client
"""
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('127.0.0.1', 3000))
s.recv(1023)
s.close()
```

## WSGI是什么
- 全称是Web Service Gateway Interface（Web服务器网关接口）。是Python中定义的一个网关协议，规定了Web Server如何跟应用程序交互
- WSGI分为Server和Application两部分。Server监听端口接收外部的请求，Application处理请求，处理完后设置对应的状态和header，并返回完整的body。Server拿到响应数据后，进行HTTP协议的封装，最终返回完整的Response
- 实现的Application必须是一个可调用对象，需要接收环境变量和一个回调函数。
- application中可以包括多个栈式的中间件。

### uwsgi
是uWSGI服务器的独占协议，定义传输信息的类型

### uWSGI
全功能的HTTP服务器，实现了WSGI、uwsgi、http协议。

## Python多重继承时super()的调用
- 旧式类采用深度优先搜索
- 新式类采用广度优先搜索，新式类继承自Object

## GIL线程全局锁
- GIL全局锁原因：CPython 内存管理不是线程安全的，因此需要GIL来保证多个原生线程不会并发执行Python字节码。
- GIL遵循的原则是：一个线程在运行时，其他线程睡眠或等待I/O操作
- GIL释放的情况
  - 协同式多任务处理: 一个线程开始睡眠或等待I/O时，会释放锁
  - 抢占式多任务处理: Python的线程利用C的pthread，通过操作系统调度算法进行调度。为了让各个线程平均利用CPU，python会计算已执行的代码量，超过一定阈值后会强制释放GIL，触发操作系统的线程调度。这会导致GIL的多线层不能有效利用多核CPU的并发处理能力
- 解决方案：使用多进程替代多线程或使用asyncio

## 什么是闭包
- 当一个内嵌函数引用其外部作用域的变量，就会形成一个闭包。闭包的变量在函数运行后不会释放掉，
而是和函数一同存在
- 必须要要有一个内嵌函数
- 内嵌函数必须引用外部函数中的变量
- 外部函数的返回值必须是内嵌函数


## 面向对象的三个基本特征：封装、继承、多态

### 封装
把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

### 继承
它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。

### 多态
- 允许你将父对象设置成为和一个或更多的他的子对象相等的技术
